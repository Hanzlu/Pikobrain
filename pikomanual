PIKOBRAIN MANUAL v1.6
Hanzlu (2019-2023)
---------------------

THE FOLLOWING TERMS OF USE APPLIES TO THIS AND ANY PRIOR VERSIONS OF PIKOBRAIN:
I, HANZLU, CLAIM TO BE THE CREATOR OF PIKOBRAIN. BY USING PIKOBRAIN AND ANY FILES ALONGSIDE IT,
YOU RECOGNIZE THAT YOU ARE NOT THE CREATOR OF IT,
AND THAT YOU MAY NOT USE PORTIONS OF IT FOR COMMERCIAL USE, WITHOUT THE CONSENT OF HANZLU.

----------

Pikobrain is unlike other systems. This document attempts to detail how Pikobrain works.

The TECHNICAL chapter of this document provide information of how some special things are implemented in Pikobrain.
For more detailed information read the code, or contact Hanzlu.

Lines starting with ** in this document are technical details. Lines starting with ! are warnings necessary to keep in mind.
The £ is a reminder for myself to check those sections when updating this file, as they depend on the size of Pikobrain.

TABLE OF CONTENTS:
1.INTRODUCTION
2.INSTALLATION
3.COMMANDS
    A.ARGUMENTS
    B.FILES
    C.FOLDERS
4.TEXT EDITOR
5.CODING
    A.EXAMPLE
    B.COMMANDS
6.TROUBLES
7.OS MEMORY USAGE
8.CUSTOMIZATION
9.VERSIONS
10.TECHNICAL
Chapters 1, 2, 3, 4 and 6 are adviced for new users.


1.INTRODUCTION
--------------
The purpose of Pikobrain is to make a small but useable BIOS based 16-bit assembly (NASM) operating system, improved depending on needs.
Commands are entered by single key presses (except arguments), and it uses the hexadecimal number system.
The keyboard is automatically US character set. All source code is in the piko.asm file.

The name Pikobrain comes from the 'big brain meme'. Piko means 10^-12 which is small, just like Pikobrain is supposed to be.
Development began in late 2019, and has continued in unregular patterns of activity.

Special words used in this document:
Bulk, used to describe multiple (consecutive) files used together as one large file.
The Input, the command prompt/shell/terminal.

This document is the best form of help for using Pikobrain.
Within Pikobrain the list of commands can be shown by typing the command 'e0101' when having entered the OS (in the "home" folder).
(This opens the text editor. Press escape to leave it when done reading)
If there are any questions, troubles or ideas for improvements, please contact Hanzlu on GitHub or forum.osdev.org


2.INSTALLATION
--------------
Pikobrain is expected to run on most modern machines with BIOS. It can access at most 8GB of hard disk space, even if the hard disk is larger.
Keyboard and screen are essential, as well as a USB/floppy port for booting on real hardware.

Real Hardware:
On real hardware, USB drives are the preferred mode of installation. CDs seem to work too, but are not directly supported.
On Linux the ' sudo dd if=piko.bin of=/dev/sdb ' command can write the piko.bin file to a USB drive.

VirtualBox:
Make sure to create a floppy disk controller in the virtual machine settings, and place the piko.flp file into it.
4MB hard disk and RAM are well enough. It is not necessary to remove the piko.flp file after having booted from it.

QEMU:
Whereas VirtualBox is the main target, QEMU works with necessary changes and settings.
Search for the word 'QEMU' in the piko.asm file, and uncomment the two lines 'popa' and 'ret', to prevent the color changing.
Assemble the code and create the piko.flp file using the two commands mentioned near the end of the piko.asm file.
Create a virtual hard disk using ' qemu-img create piko.img <size> ' where <size> is at the least 32k.
Run the virtual machine using ' qemu-system-x86_64 -fda piko.flp -hda piko.img -boot a ' or equivalent.

Booting from the USB:
If the boot is sucessfull the screen should change color. Pikobrain is now installed on the hard drive.
It is possible to use Pikobrain commands at this stage, but all commands will operate on the USB rather than the hard drive.
This is also the only time the j (jump) command works, as it does not work when booting from the hard drive.

Booting from a floppy (piko.flp) will also allow the use of commands when the screen color changes.
However, all operations will be done on the hard drive and the j command will NOT work.
**It is not necessary to remove the piko.flp from the floppy drive.
**The color should not change when using QEMU.

When Pikobrain has been installed (when the screen changes color), remove the USB and reboot from the hard drive.
If the screen does not change color, the installation might have been unsuccessfull (QEMU excepted).
Try pressing t, which should display the time. If this works, certain parts of Pikobrain might still work.

When booted up Pikobrain goes to the Input, i.e. the command prompt.
The Input is not marked with any character, and you return to the Input whenever a command has finished.
To make sure you are at the Input, test the t command, or another single-key command.

When Pikobrain has been installed on a machine for the first time, run the o command by pressing o.
If the hard drive is larger than 32kB and the second number is not 3F, please contact Hanzlu.


3.COMMANDS
----------
In Pikobrain commands are run by pressing a key, often a lowercase letter.
Many commands also take arguments. Arguments are often inserted as two-digit (or more-digit) hexadecimal numbers.
Hexadecimal numbers are ALWAYS written in UPPER case such as B8. (This is for aestethic reasons)
When pressing a command key it is not displayed on the screen, but the arguments are.
To quit writing a command, perhaps due to a mistake, press backspace. This cancels the command entirely, and it must be retyped.
**Pikobrain does not store command input in a buffer. **Pressing backspace while typing a command clears the stack.

These are the commands taking no arguments (except i and o), and are entered by pressing one key:

t, time:
Displays the current time in 'yyyy/mm/dd hh:mm:ss' format. If the time seems wrong, change it via the BIOS settings.

enter, enter:
Newline and carriage return as expected.

n, new:
Clears the screen and moves the cursor to the top left.

arrow keys, arrow:
Moves the cursor in the expected directions.

b, back:
Moves the cursor to the top left of the screen.


    A.ARGUMENTS

The following commands take multi-digit numbers as arguments. Such arguments are always of a certain length.
For example if a command requires a two-digit number, and you want to write 3, you should write 03.
For example if you wish to write 1F as a four-digit number, write 001F.
Some commands require more than one multi-digit numbers, but they are simply written in a row.

k, kalculator:
Enter a four digit hexadecimal number. A newline is automatically written. Enter a second four digit hexadecimal number.
Then press a number key for operation according to this list:
1=add
2=subtract
3=multiply
4=divide
5=modulus (remainder in division)
6=and
7=or
8=xor
9=not (the second number must still be entered, even though it doesn't matter)
0=floating point division (four-digit floating point part of a division)(read about the . command)
After entering an operation the answer is displayed as a four-digit number.
The calculator overflows after FFFF and does not support negative numbers directly.

K, Kagain:
The K command uses the result from the last calculation as the first number.
Thus, only enter the second number and then press a key for the operation.
This command should be used immediately after having used the k command.
**It uses the value in the cx register, i.e. doesn't store the result elsewhere.

h, hex:
Enter a four-digit hexadecimal number, which gets converted into decimal and displayed.

x, xdec:
Enter a 5-digit decimal number (max 65535), which gets converted into hexadecimal and displayed.

. (dot), float:
Enter a 4 digit hexadecimal number. This is the floating point part of a number. For example 1/3 = 0.5555 in hexadecimal floating point.
For example entering the value 5555 converts it into a decimal floating point number: 0.333328
(**This is what Pikobrain outputs in this case)
This answer is displayed as a dot followed by six digits.
This command is not 100% accurate in all digits. Often the first 4 digits are accurate, or the answer is at least close to the right one.


    B.FILES

Pikobrain always enters folder 000000 when started. 000000 is called the 'home' folder.
£Files 01-0B in the home folder contain the Pikobrain code, and should probably be untouched.
File commands often take a file number as argument. A file number is in the range 01-3F.
**If the o command does not return 3F as its second number, file commands will not work.
File commands often also ask for the number of files to be read, i.e. the length/size of the Bulk. This number is two digits too.
Files in Pikobrain are automatically 512 bytes long **i.e. sectors on the hard disk.
The Text Editor, and other commands allow manipulation of multiple consecutive files as one large file, called a Bulk.

w, write:
Enter a file number. You can now write to the file. The w and e commands enter the Text Editor, explained in the TEXT EDITOR chapter.

e, edit:
The w command makes you write a file from scratch, while e allows you to continue writing to an existing file.
The e command requires the file number and a second argument which is the number of files to read.
In order to open the Bulk starting at file 20, with length 3, you'd type e2003, which would open files 20, 21 and 22 as a Bulk.
Reading files is also done with the e command. Press escape when finished reading.
By reading file 01 in the home folder (000000) you'll get a list of available commands.

d, delete:
Enter a file number and the number of consecutive files to delete. In each file, a null character is placed in its beginning.
This is how Pikobrain checks if a file is empty, i.e. not existing. The p command can be used to recover deleted files.
To delete a file you can also write to it using the w command, and immediately save.
It is also possible to copy empty files into the files to delete.

m, memory:
Displays a file in hexadecimal form. As argument, enter a file number.
Each row begins with a number and a : (colon), telling the index of the row.
Then the 16 hexadecimal byte values of that row are displayed. Null characters (ASCII 00) is displayed as "..".
Each row ends with the row in ASCII format, where ASCII values less than 20 (HEX) are displayed as *.
Only half of the file is shown at first. Press any key to display the second line as well. **The index overflows and goes from zero again.
**To only show the first half, use Ctrl+Break. This also applies to the v command:

v, visible:
Same as memory, but asks for a second argument, which is a two-digit hexadecimal number.
Every instance of that number/character/opcode will be displayed as two dots "..".
**Null characters are not displayed as "..", unless that is the argument. 

p, place:
Allows you to write a byte to a certain location in a file.
Enter the file number, then a four-digit hexadecimal number for the location (index) of the byte to alter. A newline is outputted.
Then the current byte at the location is outputted. Now input the byte to write, as a two-digit hexadecimal number.
To write multiple consecutive bytes: press enter, be displayed with the next byte, then write a new byte, and so on.
To exit the command, press any key except enter AFTER you've written a last byte value.
!Pressing backspace will cause all the changes to be unsaved, so misspelling is not adviced.
Check the CUSTOMIZATION chapter to read about changing screen colors. The command can be used to recover files that have been deleted.

l, link:
Concatenates two Bulks together as one, and stores as many files as is necessary to cover the new Bulk.
Enter the last file of the first Bulk. Enter the first file number and the number of files of the second Bulk.
For example l152004 would link file 15 with 4 files starting from file 20.
The command does not work if the first file is empty or completely full. Use the c command for those cases.
(Read about the i command to know if a file is completely full)

c, copy:
Enter a file number for the source file, and its size, i.e. the number of files to read.
A 'w' character should be displayed. Enter the destination folder's number (6-digit hexadecimal number or using a shortcut).
Enter the destination file's number. You will be moved to the destination folder.
(Read about folder numbers in the FOLDERS section)

j, jump:
The j (jump) command can only be used when booting from a USB (or CD?).
This command allows you to copy files between the USB and hard drive. 
First enter if the USB or hard drive will serve as source. Pressing 0 specifies the USB, while pressing 1 would be the hard drive.
Then enter the rest of the arguments the same way as the c command works:
File number, number of files, (a 'w' will be displayed), folder number (shortcuts possible), and finally the destination file's number.
(Linux) To get a file onto the USB, begin by concatenating it to piko.bin using ' cat <yourfile> >> piko.bin '
        Then write the piko.bin file to a USB stick and boot from it. (Not guaranteed to work)
        (Linux writes enter only as a line feed, whereas Pikobrain also require a carriage return)
Pikobrain uses no recognized file system, but it is possible to read sectors from the USB using the 'head' command on Linux.
£In order to read file 0C of the USB and place it into a file 'test.txt', do:
'sudo head -c 6144 /dev/sdb | tail -c 512 > test.txt ' (Here 6144 specifies the file since 0x0C * 512 = 6144)
Example of the command: j00C01[w]00000F20 (The user should not write [w] as w is outputted by the system)
The command above would move file 0C from the USB into folder 00000F, file 20, on the hard drive.
**NOTE Whatever folder number the USB is at when running the j command, will be used as the destination folder.
       So, to move a file in folder 000002 on the hard drive to the USB, you should first go to that folder on the USB (yes USB).

o, os:
Displays information about the drive/device that you booted from.
First number is the highest folder number you can enter. This number should always be known by the user.
NOTE the number consists of three separate 2-digit hexadecimal numbers. None of these can be exceeded when accessing a folder.
For example my test machine displays the number 03FEFE, which means I cannot enter folder 03FFFE, since FF > FE.
The highest possible value the o command could give is 03FFFF. The first number never exceeds 03.
The second number the o command tells the highest file you can access within any single folder.
If this number is not 3F, you should contact Hanzlu, as file commands will not work.


    C.FOLDERS

Make sure to test the o command before dealing with folders. Exceeding limits means trying to access 'unexisting' folders.
A folder number then, is a six-digit hexadecimal number, actually made up of three separate two-digit numbers.
When inserting a folder number as a command argument some shortcuts can be used:
Pressing tab twice selects the current folder. This outputs two circles.
Pressing the h key selects the 'home' folder (000000).
Pressing semi-colon twice allows you to insert just the last two digits of the folder number.
By using shortcuts you don't need to enter an entire 6-digit folder number.

f, folder:
Changes the folder to the 6-digit hexdecimal number given as argument. Make sure not to exceed limits. Shortcuts can of course be used. 

i, info:
Displays the folder number and the files in the folder.
Only files that do not have an ASCII 00 (null) character as its first character are displayed. (Such files are seen as empty.) 
Files are displayed with their number, followed by a dot and the first 10 characters of the file.
The first 10 characters can therefore be used as a "file name", even if Pikobrain makes no use of such.
Special characters outside of the range ASCII 20-7F are displayed as stars *, since they can cause unexpected behaviour.
If a file does not have a null character as its last character, the dot will be a : (colon) instead to show that the file is full.
The colon makes it possible to spot Bulks. (This works properly only for files created with the Text Editor)

s, search:
Enter a character, word or string. Backspace can be used. Press enter to start the search.
The command displays the files in the current folder which cointain the input string, and the location (index) of the string in each file.
When entering a string, you can write * characters to mark that that specific character can be any character. (Wildcard)
After pressing s for the command, you can press f1 to search for the last string searched for.
It is also possible to write some characters and then press f1, which will replace the characters in the last string with the new ones.
As an example of this: if you searched for 'hello' the first time, and then the next time you type HE and then press f1:
The string you will search for is now 'HEllo', as it will reuse the characters of the old string which were not overwriten.
!It is not possible to overwrite all characters of the last string and then press f1.
The * (wildcard) also works for f1 and f2 in the Text Editor, and the f1 replacement also works for f1 in the Text Editor.
**The search buffer is 112 bytes wide. The same buffer is used for f1 in the text editor.


4.TEXT EDITOR
-------------
The text editor works as you'd expect with most normal keys, but there are certainly things that are different.

Special keys are summarised as:
`         save
~         index
\         special-char
|         paste
tab       copy
shift+tab cut
escape    quit
insert    to-top
delete    to-bottom
home      top-left
end       bottom-right
page up   previous line
page down next line

The f keys are summarised as:
f1, find
f2, re-find
f3, replace
f4, quick-save
f5, quick-fix
f6, goto-index
f7, link

Keys are now described in closer detail:

Enter, works as you'd expect.
**Stored as two characters (0xD and 0xA ASCII, which are seen as one by the editor, so backspace erases both at once)
Backspace, works as expected, but will not erase if the cursor is in the top left.
Side arrows, works as expected, but will not scroll the screen. (Will do nothing if the cursor is in top-left or bottom-right)
Up/down arrows, goes to the end of the line in the arrow's direction. (Will not scroll, and stops in top-right or bottom-left at most)
In other words, arrows and backspace does not scroll, but enter does.

In order to scroll you should use page up and page down. They scroll one line.
Using page down to scroll everything away will cause bugs. Page up will not scroll if the page is already at the top.
The cursor remains by the same character when scrolling.
Scrolling so much that the cursor disappears might cause bugs. Try pressing the home key, or if necessary the delete key to continue writing.

The home key, will move the cursor to the top left of the screen.
The end key, will move the cursor to the bottom right of the text. If the cursor disappears this key will not work.

The insert key, will scroll the whole file to the top.
The delete key, will scroll the whole file to the bottom. (Re-reads the whole file)
On laptops the insert and delete keys might be on the numpad, or they'll be next to the function keys.

In order to copy text, press the tab key. Pikobrain remembers the character at which the cursor is.
When pressing the tab key a second time, Pikobrain will copy all text between the two key presses, including those on the cursors.
When pressing the tab key for the second time you can use shift+tab instead, to cut the text rather than just copying it.
When cutting text, the file is re-read until the location of the cutted area.
To paste text, press the '|' key (shift). It's possible to copy-paste between files.
£**The copy buffer is 2.25kB large, exceeding this limit will cause terrible bugs.

You can write special characters (ASCII 00-FF).
Press the \ key and type a two-digit hexadecimal number for a character's ASCII representation.
Some characters in the range 00-1F might be 'invisible', cause bugs and not be printed expectedly, but will still be stored.
!NOTE! Do not cancel the writing of the number by pressing backspace, as this returns you to the Input, and the file will not be saved.

Holding shift and pressing the ` button (left of 1) displays a '~' character and a four-digit hexadecimal number.
This number tells the index of the character the cursor is on. Press any key to continue writing.
By pressing f6 and typing a four-digit hexadecimal number, the cursor will go to the character at that index.
!NOTE! Do not cancel the writing of the number by pressing backspace, as this returns you to the Input, and the file will not be saved.
If the index typed is larger than the size of the file content, you will be moved to the end of the file.

In order to search for a string in the text, press f1. Enter a string and press enter.
The cursor will jump to the first instance of the string in the text.
In order to search for the next occurance, press f2. This will search for the next occurance, starting from the location of the cursor.
If the string is not found when using f1 or f2, the cursor will go to the end of the text.
You can replace a string by using f1 to specify the string that will be replaced, and then f3 to type the string to replace it with.
(Press enter after you've written each string) All instances of the f1-string will be replaced with the f3-string, and the text is re-read.
Read about the s command to learn about an additional f1 and * functionality that can be used in the Text Editor as well.
You can NOT use * characters as wildcards when using f3, as the * character will be seen as a * character.
When using f3 you can press f1 to use the old f3-string again when replacing, instead of retyping the "f3-string".
**The f1- and f3-strings are stored in separate buffers of sizes 112 and 128 bytes respectively. Inputted strings should not be longer.

!Lines MAY NOT end with spaces, as this causes the cursor to work weirdly.
!You should not fill a whole line with characters, as this causes bugs. Use enter at the end of lines.
If you press the f5 key, all spaces before newlines will be removed, and newlines will be added where a line does not end with enter.
In other words f5 fixes these problems if they exist in the file.

In order to save a file you press the button to the left of the 1 key. This should display `, which means the file has been saved.
In order to quit the Text Editor, without saving, press escape. This should display an arrow.
Pressing f4 will do a quick-save and allow you to continue writing.

f7 Allows you to use "file links". A file link can be placed within a file and can be used to open another file.
For example, if I write 0000002003, and then move my cursor onto it and press f7:
The text editor would open folder 000000, a Bulk starting at file 20 with length 3. i.e. 20,21,22 as a Bulk.
In other words it is the folder number, the file number, and the number of files as one large number, without spaces.
It's not possible to use shortcuts, except to use the current folder; then you can write a * instead of the folder number.
So with the above example it would be *2003 if we were already in the home folder.
!NOTE! There must be a space before this "link", and the cursor must be on the link (or one step to the right of it)
The file you were inside will not be saved before the new file is opened. Use f4 to save it if necessary.

The Text Editor saves as many files as necessary to store the whole text written, as a Bulk.
Make sure this does not overwrite other important files, or that it exceeds the 3F files per folder limit.
**The copy buffer is reset when you save or exit. Copied strings will still remain in the buffer, so you can paste them into other files.
**If the last file in the Bulk is full (contains 512 bytes of actual text) the text editor will save one more file, and it will be empty.

If the Text Editor or cursor begin to bug, try the following things:
(Press f5 to remove spaces before newlines and make lines end with enter.)
Press home to move the cursor to top left.
Press delete to re-read the file.
Press ` to save the file.
Press Ctrl+Break to return to the Input. If this doesn't work, you must restart the computer.

!Lines may not end with space, and lines must end with enter (except the last line). Read about the f5 key to fix this.
!Do not press backspace while typing a number for f6 or \, as this will jump to the Input, without saving the files.


5.CODING
--------
**The OS uses a buffer starting at 0x1200:0x0 (20-bit segmentation) for reading files, also when reading machine code for the r command.
**User programs should especially not use that buffer, as it would alter the very code the program is running from.
To show how Pikoasm translates to NASM assembly code ('<code>') is used.

Pikobrain has a limited assembler. The assembly language is a custom version of assembly language called Pikoasm.
The assembler can only assemble one Bulk at a time, and the code is written in UPPER case, and uses hexadecimal.

If a mneumonic can use either a register or an immediate value as source, the option is indicated by the mneumonic.
For example, to move bx into ax you must specify that the source is a register with R, by using the MR (move register) mneumonic: MR AX BX
On the other hand, if the source is a number, the mneumonic has an N, such as SN AL 10 ('sub al, 0x10') (subtract number)
Immediate values used as source are of a certain length, depending on the destination register's size, sort of like arguments for commands.
In other words, if an immediate is a byte, write it as a 2-digit number; if a word, write it as a four-digit number.
The correct syntax of a statement is as follows: <MNEUMONIC> <ARGUMENT> <ARGUMENT> (with spaces between the parts)
It is possible to have multiple statements on one line. I recommend using a comma to separate statements.
Example: MN AX 0001,AR AX AX
To avoid syntax errors, use the recommended methods of spaces and newlines/commas.

All the basic registers (AX, AH, AL, BX, BH..) are usable. You can also use SI and DI, however they are called SX and TX.
In order to stop a program, you should use the E (end) mneumonic. This returns control to the OS, and takes you to the Input.
Here is a list of 2-character mneumonics, taking 2 arguments, destination and source.
Each require either an R or an N at the end such as MR or MN, not just M:
M, move
A, add
S, subtract
B, both (and)
O, or
X, xor
C, compare
Example: BN DL 3E ('and dl, 0x3e')

Here is a list of 2-character mneumonics, taking two arguments, a register and a byte immediate:
Z, (shift), ZR = shr, ZL = shl
Q, (rotate), QR = ror, QL = rol
NOTE 16-bit registers also only take byte values as arguments.
Example: ZR BX 01 ('shr bx 1h')

Here is a list of 2-character mneumonics, taking only a byte as argument:
G, GI = in, GO = out
NOTE the al register is automatically used so don't specify a register, just the immediate (port).
Example: GI 64 ('in al, 0x64')

Here is a list of 1-character mneumonics in Pikobrain, taking one argument.
Mneumonics marked with a * can only take 16-bit registers as arguments.
Those marked with a / can only take a byte immediate as argument, and those with a \ can only take registers:
T, times\ (mul)
D, divide\
H, higher\ (inc)
L, lower\ (dec)
N, not\
I, int/
K, kreate/ (db) Can be used for opcodes not supported by Pikoasm. For example: K ED ('db 0xed' => 'in ax, dx')
U, push* (if you want to push ax you write UA, so no X and everything in one mneumonic.)
(UA, UB, UC, UD, US and UT are in other words the ones you can use. Same for pop below.)
P, pop* (PA, PB, PC, PD, PS, PT)

Control flow:
Labels are marked as string starting and ending with dots such as .LOOP. To jump to a label, use 'JM <label name>.'
Label names end with a dot but do not start with one when jumping, so in order to jump to the LOOP label, write 'JM LOOP.'
In order to call a function, use F (function) ('call') followed by a label name similar to JM. Example: 'F LOOP.'
**16-bit far jumps are automatically used.
In order to return from a function call, use R ('ret').
The following conditional jumps exist:
JE, jump equal
JN, jump not equal
JG, jump greater
JA, jump above
JL, jump less
JB, jump below
The conditional jumps works like JM regarding the labels.

Segmentation:
Segmentation is possible with using combinations of es, fs, gs with bx, sx (si), tx (di).
In order to set a segment register such as 'mov es, ax', do: MI AX ES (The M specifies mov and I specifies "into")
In order to get a segment register such as 'mov cx, gs', do: MO CX GS (The O specifies "out of")
Note that in both cases the segment register is the second argument. All ordinary registers can be used for this.

In these mneumonics all registers es, fs, gs, bx, sx, tx are represented by their first letter when forming segment:offset.
In order to move a register into memory you write a 5-letter combination such as MFTCH ('mov [fs:di], ch').
The first letter is always M to specify 'mov'. The second letter is the segment register (E, F or G).
The third letter is the offset register (B, S or T). The two last letters specify an ordinary register, and those are:
AX, AH, AL, BX, BH, BL, CX, CH, CL, DX, DH, DL, SX or TX.
It is not yet possible to use immediate values as source in Pikoasm.

In order to move content from memory into a register you do something like MDXEB ('mov dx, [es:bx]').
The M is 'mov', the next two letters the ordinary register, and the last two specify the combination of a segment and offset register.

Macros:
To simplify some of the programming, Pikoasm provides some macros/functions listed below.
The list describes the macros and lists the registers that are affected by using the macro:
WA, converts al from ASCII to HEX. If al is 42 (ascii B) for example it becomes 0B as that is hexadecimal. [al]
WE, prints a newline. [ax]
WF, same as the f command from the Input. Let's the user insert a folder number and stores it at 0x1000:0x1fa-0x1fc. [ax, cl, fs, si]
WG, allows the user to write a string to the search buffer at 0x1161:0x0 (gs:di points to it). [ax, gs, di] £
WH, convert al from HEX to ASCII. If al is 0C for example it becomes 43 (ascii C). [al]
WN, let's the user input a two-digit number stored in cl. [ax, cl]
!The user cannot press backspace as this will make the program end and jump back to the Input.
WO, opens files into the location of es:bx. Before calling the macro, set es:bx pointing to a free buffer.
    The macro asks the user for a file number and number of files, and then reads those into the buffer [ax, cx, dx]
WR, returns a random number into al. [ax, fs, si] (ah is also a bit random, if not used frequently)
WS, is used to set dh, ch, and cl (contain folder number) before a file operation (int 13h). cl should be set to the right file prior.
    It takes the values inserted when using WF, and are all set to 0 at bootup. dl is set to 0x80 [ax, cx, dx, fs, si]
WW, works like the n command in the Input, i.e. clears the screen. [nothing]
WX, outputs the value in ch as ASCII. If ch is 34 for example, it will be printed as "34". [ax, ch]
!When Pikobrain is updated it might be necessary to re-assemble programs using macros, as those might have been affected.
**The macros are hardcoded far-calls not interrupts.

Other things:
E, End. Will return control back to the OS (** with a far return).
This is necessary to end a program, and there can be multiple in one program.
;, comment. All text until the next newline or eof will be ignored by the assembler.
", string. Prints any text between two " characters. It is necessary to be in a text video mode for it to work. Affects the ax register.


    A.EXAMPLE

An example program which outputs all numbers between 00 and 63 (hex):

MN CH 00   ;CH = 00
.LOOP.     ;MAKE A LOOP LABEL
UC         ;PUSH CX SINCE CH IS CHANGED BY WX
WX         ;CALL THE WX (XTOX) MACRO WHICH OUTPUTS CH AS A HEXADECIMAL NUMBER
PC         ;POP CX TO GET BACK THE VALUE OF CH
H CH       ;INCREASE CH
CN CH 64   ;COMPARE CH TO 64
JN LOOP.   ;IF NOT EQUAL: JUMP BACK TO THE LOOP LABEL
E          ;END THE PROGRAM


    B.COMMANDS

a, assembly:
Enter the file number of the first file in the program code, and then the number of files.
An 'a' character should be displayed meaning the assembly finished. If there is more/other text, there's an error (read below).
Now enter the file where the binary code will be placed. The number of files the machine code Bulk takes up is displayed.
The assembler places a \ (backslash) at the beginning of the machine code, to mark it as an executable for the r command.

Errors
If there is a four-digit number and an 'e', this means you have a syntax error.
The number tells the character index of the error in the source code. f6 can be used in the Text Editor to go to the location.
If there is a label name followed by a dot, this means there's a label error related to the particular label.
If there is also an 'a' character it means the program as been assembled, but with errors.
In that case the assembler is still asking for a destination file, but you can also press backspace to cancel the command.

r, run:
The r command runs binary files, such as assembled code. Enter the file number of the first binary file in the program.
Enter a second two-digit hexadecimal number for the number of consecutive files to be read.
NOTE the i command might not tell that a program spans multiple files, so if it's likely, you might need to check it yourself.
Unless the first character of the program is a \ backslash it will not run. This is to prevent crashes due to running non-program files.
**The r command makes a far call to the program code, so the E mneumonic is necessary to return control.


6.TROUBLES
----------
By pressing Ctrl+Break, the OS will stop whatever it is doing and jump to the Input (if possible).
This can be used in case something crashes or a program goes into an infinite loop etc. The n command might also be necessary.
If this does not solve the issue, try restarting the machine. If that does not help, try reinstalling Pikobrain on the machine.
If nothing seems to solve the issue, please contact Hanzlu on GitHub issues or on the OSDEV Wiki Forums.

I will not stand responsible for your use of the OS, it is on your own risk. That does not mean it is not safe.
I test and improve the OS to eliminate bugs, increase user-friendliness and remove unwanted consequences.
The OS has not been built with security in mind, so misclicks may alter OS files, or even your own files.
Ctrl+Alt+Delete can be used to restart the machine, but it doesn't always work. Turn off Pikobrain by turning off the computer.


**7.OS MEMORY USAGE
-------------------£
Pikobrain uses some parts of the RAM for its own needs. This is a list of segments it uses and their use:
0x1000:0x0 - 0x1000:0x15ff, OS machine code
0x1160:0x0 - 0x1160:0x0002, Random number generator
0x1161:0x0 - 0x1167:0x000f, Search and find buffer
0x1168:0x0 - 0x116f:0x000f, Replace buffer
0x1170:0x0 - 0x11f0:0x00ff, Copy buffer
0x1200:0x0 - 0x1a00:0x0000, Normal file read buffer (maximum size, depends on size of Bulk or program)
0x1200:0x0 - 0x3000:0x0000, Assembler buffer (this buffer may be altered except for the file read buffer above)
User programs should not run in buffers lower than 0x1200:0x0, or in the space starting from 0x1200:0x0 which a running program occupies.
User programs do best by using buffers at 0x2000:0x0000 and above for example.


8.CUSTOMIZATION
---------------£
By using the p command to alter the value at location 001B in file 02 of the OS files, the screen color can be changed, using BIOS colors.
After using the p command to change the color, restart the machine to get the actual effect (remove bootable USBs/floppies too).
This value can also be changed in the source code in piko.asm. Search for the word 'color'.


**9.VERSIONS
------------
The version number is made up of three numbers:
The first number increases if a major change related to hardware is added to Pikobrain.
The second number increases if a larger system change is made to Pikobrain.
The third number increases whenever properly updated versions of the piko.asm file is uploaded to GitHub.
The third value will not exceed 11, and if it does it will be considered a 'larger system change' and the second number increases instead.

Some notable versions are:
v0.5   introduced the hexadecimal file system
v1.0   first version to work on real hardware
v1.2   introduced the assembler
v1.4   allowed Bulk editing in text editor


**10.TECHNICAL
-------------

Design of Pikobrain:
The way Pikobrain is made is quite alternative. I've not used the most common practices in code managment and long term planning.
I haven't really had any experience before starting with new features, and thus they may become a bit funky. I like that though.
Whereas I may have been inspired by things I've seen, the only code I've copied is the one I used to get started with the bootloader.
Neither have I looked into typical ways to handle various things, but just implemented a method I could come up with.
I'll describe here some of the more special home made features of Pikobrain.

Bootloader:
The bootloader simply reads the files from the booted drive and jumps to that code.
It can tell if you are booting from the hard disk or if the OS is supposed to be installed.
QEMU doesn't work as its BIOS works differently from VirtualBox and my PhoenixBIOS test machine.
Since the bootloader code is small, I added a list of commands into it, which can be read in the text editor.

The Input:
The Input/command prompt reads characters continuously instead of first storing them in a buffer.
This is why backspace cancels the writing of the whole command, and it must be rewritten.
The Input really only checks what command key you press and jumps to that command/program, which then continues to read the arguments.
Eventually programs will jump back to the Input, and so the loop goes on and on.

Hexadecimal File System:
Pikobrain only uses hexadecimal as it is much easier to convert than decimal.
The folder number is stored in memory and contains the values necessary for int 13h CHS reading.
It is the most simple way for the computer to understand.

Text Editor:
There's not a good way to explain this program of a mess. Read the code, good luck.
It has come a long way since the days when you could not even use backspace though.
It is almost surprising how many features need to be implemented to make a normal text editor.
In a sense Pikobrain is just a big IDE that can boot.
loop:
 a.rewrite screen
 b.get key input
 c.write char / do special function
The rewriting of the screen is done by writing each line until a new line character, and then adding spaces;
except for at the last line of the screen where it has to end on step earlier in order to not scroll.
In order to keep track of the scrolled window to show, a variable containing the index of the top-left-most character is stored.
 
Random Numbers:
Uses the current clock tick to update ah, which updates al. Then ax is rotated left one step and stored for the next request.

Floating Point:
The calculator uses long division to get a four digit floating point value as answer.
The . (float) command converts the hexadecimal float to decimal float by using the equation:
x/16=y/10 => y = (x*10)/16 ,where x is the hexadecimal value and y is the decimal
Using mul will result in the result being placed into DX AX.
By multiplying the hexadecimal value by 10 the "overflow" that does not fit in AX is placed into DX.
If you were to divide DX AX by 16 you would move the value in DX into AX,
so Pikobrain directly output the value in DX (DL) as a decimal number.

Assembler:
Uses two stages to directly create binary files.
The first stage directly converts assembly to binary code, by writing the opcodes and values depending on register combinations.
It stores jmps and labels in their own buffers which include the label names and their location in the machine code.
The second stage goes through the list of jmps, and matches them with the labels,
calculating the right length of the jmps and writing these to the machine code.
Jumps are automatically 16-bit, so no near jumps. This way I can always leave a 16-bit gap during the first stage.
